{"version":3,"sources":["../src/string-ends-with-x.js"],"names":[],"mappings":"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","file":"string-ends-with-x.esm.js","sourcesContent":["import attempt from 'attempt-x';\nimport toInteger from 'to-integer-x';\nimport requireObjectCoercible from 'require-object-coercible-x';\nimport toStr from 'to-string-x';\nimport isRegExp from 'is-regexp-x';\nimport numberIsNaN from 'is-nan-x';\nimport clamp from 'math-clamp-x';\nimport toBoolean from 'to-boolean-x';\nimport methodize from 'simple-methodize-x';\n\nconst ERR_MSG = 'Cannot call method \"endsWith\" with a regex';\nconst charCodeAt = methodize(ERR_MSG.charCodeAt);\nconst nativeEndsWith = ERR_MSG.endsWith;\nconst methodizedEndsWith = typeof nativeEndsWith === 'function' && methodize(nativeEndsWith);\n\nconst test1 = function test1() {\n  return attempt(methodizedEndsWith, '/a/', /a/).threw;\n};\n\nconst test2 = function test2() {\n  const res = attempt(methodizedEndsWith, 'abc', 'c', -1 / 0);\n\n  return res.threw === false && res.value === false;\n};\n\nconst test3 = function test3() {\n  const res = attempt(methodizedEndsWith, 123, '3');\n\n  return res.threw === false && res.value === true;\n};\n\nconst test4 = function test4() {\n  return attempt(methodizedEndsWith, null, 'n').threw;\n};\n\nconst isWorking = toBoolean(methodizedEndsWith) && test1() && test2() && test3() && test4();\n\nconst patchedEndsWith = function endsWith(string, searchString) {\n  const str = toStr(requireObjectCoercible(string));\n\n  if (isRegExp(searchString)) {\n    throw new TypeError(ERR_MSG);\n  }\n\n  /* eslint-disable-next-line prefer-rest-params */\n  return methodizedEndsWith(str, searchString, arguments[2]);\n};\n\nconst assertNotRegexp = function assertNotRegexp(searchString) {\n  if (isRegExp(searchString)) {\n    throw new TypeError(ERR_MSG);\n  }\n\n  return searchString;\n};\n\nconst getLength = function getLength(args, stringLength) {\n  let length = stringLength;\n\n  if (args.length > 2) {\n    const position = args[2];\n\n    if (typeof position !== 'undefined') {\n      length = toInteger(position);\n\n      if (numberIsNaN(length)) {\n        length = 0;\n      }\n    }\n  }\n\n  return length;\n};\n\nconst predicate = function predicate(obj) {\n  const {str, searchStr, start, searchLength} = obj;\n\n  if (start < 0) {\n    return false;\n  }\n\n  let index = 0;\n  while (index < searchLength) {\n    if (charCodeAt(str, start + index) !== charCodeAt(searchStr, index)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n};\n\n// Firefox (< 37?) and IE 11 TP have a non-compliant startsWith implementation\nexport const implementation = function endsWith(string, searchString) {\n  const str = toStr(requireObjectCoercible(string));\n\n  assertNotRegexp(searchString);\n\n  const stringLength = str.length;\n  const searchStr = toStr(searchString);\n  const searchLength = searchStr.length;\n  /* eslint-disable-next-line prefer-rest-params */\n  const length = getLength(arguments, stringLength);\n  const end = clamp(length, 0, stringLength);\n  const start = end - searchLength;\n\n  return predicate({str, searchStr, start, searchLength});\n};\n\n/**\n * The endsWith method determines whether a string ends with the characters of a specified string, returning true or\n * false as appropriate.\n *\n * @param {string} string - The string to search.\n * @throws {TypeError} If string is null or undefined.\n * @param {string} searchString - The characters to be searched for at the end of this string.\n * @throws {TypeError} If searchString is a RegExp.\n * @param {number} [length] - If provided it is used as the length of string. If omitted, the default value is the string length.\n * @returns {boolean} - `true` if the given characters are found at the end of the string; otherwise, `false`.\n */\nconst $endsWith = isWorking ? patchedEndsWith : implementation;\n\nexport default $endsWith;\n"]}